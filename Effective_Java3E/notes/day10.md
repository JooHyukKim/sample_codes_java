# Day 10. 메서드 Method와 주의사항 / Item 49~56

## Item 49. 매개변수가 유효한지 검사하라.

### 매개변수 검사를 제대로 하지 못하면 몇가지 문제가 생길 수 있다.

- 메서드가 수행되는 중간에모호한 예외를 던지며 실패할 수 있다.
- 더 나쁜 상황은메서드가 잘 수행되지만 잘못된 결과를 반환할 때.
- 더 나빠지자면 문제없이 수행되지만 미래에 오류낼 대다.

> 자바 7 추가된 java.util.Objects.requireNonNull 메서드는 유연하고 사용하기도 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다.
>

```java
this.strategy=Objects.requireNonNull(strategy,"전략");
```

public이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증할 수 있다. 예를 살펴 보자.

단언문은 몇 가지 면에서 일반적인 유효성 검사와 다르다.

1. 실패하면 Assertion Error를 던진다.
2. 런타임에 아무런 효과도, 성능저하도 없다.( 단 java 명령줄에서 -ea / --enableassertions 플래그를 설정하면 런타임에 영향을 준다.

- 생성자는 "나중에 쓰려고 저장하는 매개변수의 유효성을 검사하라"는 원칙의 특수한 사례다.
- 생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는데 꼭 필요하다.
- 이번 아이템을 "매개변수에 제약을 두는 게 좋다" 고 해석해서는 안된다.
- 사실은 그 반대다.
- 메서드는 최대한 범용적으로 설계해야 한다.
- 메서드가 건네 받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을 수록 좋다.
- 하지만 구현하려는 개념 자체가 특정한 제약을 내재한 경우도 드물지 않다.

### 핵심 정리

- 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 잇을지 생각해야 하낟. 그 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 한다. 이런 습관을 반드시 기르도록 하자. 그 노력은 유효성
  검사가 실제 오류를 처음 걸러낼 대 충분히 보상받을 것이다.

---
---

## Item 50. 적시에 방어적 복사본을 만들라.

클라이언트가 여러분의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍을 해야한다.

> Date는 낡은 API 니 새로운 코드를 작성할 대는 더 이상 사용하면 안된다.

- 외부로부터 인스턴스의 내부를 보호화려면 생성자에게서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.
- 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사한 점에 주목하자.
- 매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안된다. 대신 새로 인스턴스를 생성하여 저장한다.
- 그리고 공격을 막아내려면 단순히 접근자가 가변 필드의 방어적 복사본을 반환하면 된다.
- 새로운 접근자와 방어적 복사를 사용하면 해당 객체는 완벽한 불변으로 거듭난다.
- 접근자 메서드에서는 방어적 복사에 clone을 사용해도 된다. (처음 저장시에 새로만든 객체이므로)
- 방어적 복사에는 성능자하가 따르고, 또 항사 ㅇ쓸 수 있는 것도 아니다.
- 다른 패키지에서 사용한다고 해서 반드시 방어적으로 복사해야 하는 것은아니다. 때로는 명백한 통제권의 이전을 뜻하기도 한다.

### 핵심 정리

- 클래스가 클라이어트로부터 받는 혹으 ㄴ클라ㅣㅇ언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
- 복사 비용이 너무 크거나 클라이언트가 그 요소르 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성 요소를 수정했을 때의 책임이 클라이언트에 잇음을 문서에 명시하도록 하자.

-----

## Item 51. 메서드 시그니처를 신중히 설계하라.

- 메서드 이름을 신중히 짓자. 같은 패키지에 속한 다른 이름들고 ㅏ일관되게 짓는 게 최우선 목표다.
- 편의 메서드를 너무 많이 만들지 말자. 메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어렵다. 인터페이스도 마찬가지다. 확신이 서지않으면 만들지 말자.
- 매개변수 목록은 짧게 유지하자. 4개 이하가 좋다. 같은 타입의 매개변수 여러개가 연달아 나오는 경우가 특히 해롭다. 순서룰 바꿔 입력해도 그대로 컴파일되고 실행된다. 단지 의도와 다르게 동작할 뿐이다.
- 과하게 긴 매개변수 목록을 짧게 줄여주는 기술 세 가지를 소개하겠다.
    - 첫 번재, 여러 메서드로 쪼갠다.
    - 두 분째, 매개변수 여러 개를 묶어주는 도우미 클래스를 만드는 것이다. 일반적으로 이런 도우미 클래스는 정적 멤버 클래스로 둔다.
    - 세 번째, 앞서의 1번 2번을 혼합한 것으로, 객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용한다고 보면된다.
- 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다. 예를들어 메서드에 HashMap 대신 Map을 사용한다.그러면 TreeMap, ConcurrentHashMap, TreeMap 의 부분맵 등 어떤 Map
  으 ㅣ구현체도 인수로 건넬 수 있다.
- boolean 보다는 원소 2개짜리 열거 타입이 낫다.(isEmpty 와 같이 boolean 을 받아야 의미가 더 명확할 때는 예외다.)

```java
Thermometer.newInstance(true) // BAD
        Thermometer.newINstance(TemperatureScale.CELSIUS) // good!
```

---

## Item 52. 다중정의는 신중히 사용하라.

- 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택되기 때문이다.
    - 메서드를 재정의했다면 해당 객체의 런타임 타입이 어떤 메서드를 호출할지의 기준이 된다.
    - 타입에 상관없이 (정확히 말하자면 추상 클래스를 구현한 어떠한 클래스이던지 간에)  가장 하위에서 정의한 재정의 메서드가 실행된다.
- 한편, 다중정의된(메서드 오버로딩) 메서드 사이에서는 객체의 런타임 타입은 전혀 중요치 않다. 선택은 컴파일 타임에, 오직 매개변수의 컴파일 타입에 의해 이뤄진다.
- 다중정의가 혼동을 일으키는 상황을 피해야 한다.
    - 재정의한 메서드는 프로그래머가 기대한 대로 동작하지만, 다중정의한 메서드는 이러한 기대를 가볍게 무시하니 헷갈릴 수 있는 코드는 작성하지 않는게 좋다.
- 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.
- 다중정의하는 대신 메서드 이름을 다르게 지어주는 길도 항상 열려 있으니 말이다.
    - 예를들어 writeBoolean, writeInt, writeLong
- 생성자는 이름을 다르게 지을 수 없으니 두번째 생성자부터는 무조건 다중정의가 된다.
    - 하지만 정적팩터리라는 대안이 있다.
    - 또한 생성자는 재정의할 수 없으니 다중정의와 재정의가 혼용될 걱정은 없다.
- 같은 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안된다.

### 핵심 정리

- 프로그래밍 언어가 다중정의를 허용한다고 해서 꼭 활용하라는 뜻은 아니다.
- 일반적으로 매개변수 수가 같을 때는 다중정의를 피하는게 좋다.
- 상황에 따라, 특히 생성자라면 이 조언을 따르기가 불가능할 수 있다. 그럴 때는 헷갈릴 만한 매개변수는 형변환하여 정확한 다중정의 메서드가 되도록 선택해야 한다.
- 이것이 불가능하면 예컨대 기존 클래스를 수정해 새로운 인터페이스를 구현해야 할 때는 같은 객체를 입력받는 다중정의 메서드들이 모두 동일하게 동작하도록 만들어야 한다.
- 그렇지 못하면 프로그래머 들은 다중정의된 메서드나 생성자를 효과적으로 사용하지 못할 것이고, 의도대로 동작하지 않는 이유를 이해하지도 못할 것이다.

---
---

## Item 53. 가변인수는 신중히 사용하라.

- 성능에 민감한 상황이라면 가변인수가 걸림돌이 될 수 있다. 가변인수 메서드는 호출될 때마다 배열을 새로 하나 할당하고 초기화한다.
    - 다행히 더 나은 방법은 예를들어 메서드 호출의 95%가 3개 이하로 사용한다면 3개까지는 메서드 다중정의를하고 4번째 매개변수가 존재할 때부터는 가변 인수를 사용하는 것이다.
    - 대다수의 성능 최적화와 마찬가지로 이 기법도 보통 때는 별 이득이 없지만, 꼭 필요한 특수 상황에서는 사막의 오사시스가 되어줄 것이다.

### 핵심 정리

- 인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다.
- 메서드를 정의할 때 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할 때는 성능 문제까지 고려하자.

---
---

## Item 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라.

```java
return cheeseInStock.isEmpty()?null:new ArrayList<>(cheeseInStock); // BAD!
```

null 을 반환한다면, 클라이언트는 이 null 상황을 처리하는 코드를 추가로 작성해야 한다.

- 문제는 컬렉션이나 배열 같은 컨테이너가 비었을 때 null을 반환하는 메서드를 사용할 때면 항시 이와 같은 방어 코드를 넣어줘야 한다.
    - 클라이언트에서 방어 코드를 빼먹으면 오류가 발생할 수 있다.
- 빈 컨테이너를 할당하는 데도 비용이 드니 null을 반환하는 쪽이 낫다고 주장하지만 이는 두 가지면에서 틀린 주장이다.
    - 첫번째, 분석결과 그러한 할당이 성능 저하의 주범이라고 확인되지 않는 한, 이 정도의 성능차이는 신경 쓸 수준이 못 된다.
    - 두번째, 빈 컬렉션과 배열은 굳이 새로 할당하지 않고도 반환할 수 있다.

```java
return new ArrayList<>(cheeseInStock); // GOOD! 빈 배열을 전달해도 동작함
```

- 가능성은 작지만, 사용패턴에 따라 빈 컬렉션 할당이 성능을 눈에 띄게 떨어뜨릴 수도 있다.
    - 해법은 간단하게 매번 똑같은 빈 "불변" 컬렉션을 반환하는 것이다. 알다시피 불변객체는 자유롭게 공유해도 안전하다.
    - 단, 이 역시 최적화에 해당하니 꼭 필요할 때만 사용하자. 
    - 이유는 항상 성능이 개선되는 것이 아니므로 최적화가 필요하다고 판단이되면 수정 전과 후의 성능을 측정하여 실제로 성능이 개선 되는지 꼭 확인하자.

### 핵심 정리
- null 이 아닌, 빈 배열이나 컬렉션을 반환하라.
- null을 반환하는 API 는 사용하기 어렵고 오류처리 코드도 늘어난다.
- 그렇다고 성능이 좋은 것도 아니다.

---
---

## Item 55. 옵셔널 반환은 신중히 하라.

자바 8전에는 값을 반환할 수 없을 떄 예외를 던지거나 null 을 반환해야 했엇다.

- 예외는 진짜 예외적인 상황에서만 사용해야 하며 예외를 생성할 때 스택 추적 전체를 캡처하므로 비용도 만만치 않다.
- 그렇다고 null 처리를 하면 별도 방어코드를 작성해야하고 NullPointerException이 어디선가에서 등장한다.
- 빈 Optional.empty() 나 Optionalof(result) 또는 null 값도 허용하는 메서드에서는 Optional.ofNullable(value)를 사용하면 된다.
- 옵셔널을 반환하는 메서드에서는 절대 null 을 반환하지 말자.

### null 이나 예외 대신 옵셔널을 선택해야하는 기준은?
- 옵셔널은 검사 예외 와 취지가 비슷하다.
- 즉, 반환 값이 없을 수도 있음을 API 사용자에게 명확히 알려준다.
- 비검사 예외를 던지거나 null 을 반환한다면 API 사용자가 그 사실을 인지하지 못해 끔찍한 결과로 이어질 수 있다.
- 기본값을 설정하는 비용이 아주 커서 부담이 된다면 Supplier<T>를 인수로 받는 orElseGet을 사용하면, 값이 처음 필요할 때 Supplier<T>를 사용해 생성하므로 초기 설정 비용을 낮출 수
  있다.

### 그렇다면 어떤 경우에 메서드 반환 타입을 T 대신 Optional<T>로 선언해야 할까?

기본 규칙은 이렇다.

- 결과가 없을 수 있으며 클라이언트가 이 상황을 특별하게 처리해야 한다면 Optional<T>를 반환한다.
- 박싱된 기본 타입을 담는 옵셔널은 기본 타입 자체보다 무거울 수 밖에 없다.
    - 값을 두 겹이나 감싸기 때문이다.
    - 그래서 자바 API 설계자는 int, long, double 전용 옵셔널 클래스들을 준비해놨다.
    - 바로 OptionalInt, OptionalLong, OptionalDouble이다.
    - 그러니 박싱된 기본 타입을 담은 옵셔널을 반환하는 일은 없도록하자.
    - 단 위 셋 외 '덜 중요한 기본 타입'은 예외일 수 있다
- 옵셔널을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는게 적절한 상황은 거의 없다.

### 핵심 정리

- 값을 반환하지 못할 가능성이 있고 호출할 때마다 변환합ㄱㅅ이 없을 가능성을 염두에 둬야 하는 메서드라면 옵셔널을 반환해야 할 상황일 수 있다.
- 하지만 옵셔널 반환에는 성능 저하가 뒤따르니, 성능에 민감한 메서드라면 null 을 반환하거나 예외를 던지는 편이 나을 수 있다.
- 그리고 옵셔널을 반환값 이외의 용도로 쓰는 경우는 매우 드물다.

---
---

## Item 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라.

- 여러분의 API 를 올바로 문서화하려면 공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 한다.
- 메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다.
    - 상속용 메서드가 아니라면 어떻게 동작하는지가 아니라 무엇을 하는지를 기술해야 한다.
- 핵심 정리
    - 문서화 주석은 여러분 API 를 문서화하는 가장 훌륭하고 효과적인 방법이다.
    - 공개 API 라면 빠짐없이 설명을 달아야 한다.
    - 표준 규약을 일관되게 지키자.
    - 문서화 주석에 임의의 HTML 태그를 사용할 수 있음을 기억하라.
    - 단, HTML 메타문자는 특별하게 취급해야한다.

---




















