# Day 5. interface와 Class 설계 원칙 / Item 20~25

----
----

## item 20. 추상 클래스보다는 인터페이스를 우선하라.

- 자바가 제공한느 다중 구현 메커니즘은 인터페이스와 추상 클래스가 있다.
- 자바 8부터 default 메서드를 제공할 수 있게 되어 이제는 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다.
- 한편 둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다.
    - 자바는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의하는 데 커다란 제약을 안게 되는 셈이다.
    - 반면 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했단 같은 타입으로 취급된다.
- 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다.
- 인터페이스는 믹스인 정의에 안성맞춤이다.
    - 믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 '주된 타입' 외에도 특정 선택정 행위를 제공한다고 선언하는 효과를 준다.
- 인터페이스로는 계층 구조가 없는 타입 프레임워크를 만들 수 있다.
- ㄹ퍼 클래스 관용구와 함께 사용하면 인터페이스는 기능을 향상 시키는 안전하고 강력한 수단이 된다.
    - 타입을 추상 클래스로 정의해두면 그 타입에 기능을 추가하는 방법은 상속뿐이다.
    - 상속해서 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기는 더 쉽다.

### 핵심 정리

- 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다.
- 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공한느 방법을 꼭 고려해보자.
- 골격 구현은 '가능한 한' 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다.
- '가능한 한'이라고 한 이유는, 인터페이스에 걸려있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문이다.

---
---

## Item 21. 인터페이스는 구현하는 쪽을 생각해 설계하라.

- 생각할 수 있는 모든 상황에서 불변식을 해치치 않는 디폴트 메서드를 작성하기란 어려운 법이다.
- 디폴트는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.
- 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 피해야 한다.
- 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야한다.
- 인터페이스를 릴리즈한 후라도 결함을 수정하는게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안된다.

---
---

## Item 22. 인터페이스는 타입을 정의하는 용도로만 사용하라.

- 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다. 달리 말해, 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것이다.
  인터페이스는 오직 이 용도로만 사용해야 한다.
- 메서드 없이 상수를 뜻하는 static final 필드로만 가득찬 인터페이스인 상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다.

### 핵심 정리

- 인터페이스는 타입을 정의하는 용도로만 사용해야 한다. 상수 공개용 수단으로 사용하지말자.

---
---

## Item 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라.

- 두 가지 이상의 의미를 표현할 수 있으며, 그중 현재 표현하는 의미를 태그 값으로 알려주는 클래스를 본 적이 있을 것이다.
    - 우선 쓸데없는 enum 열거 타입 선언, 태그 필드, switch 문 등 쓸데없는 코드가 많다.
    - 여러 구현이 한 클래스에 혼합돼 있어서 가독성도 나쁘다.
    - 다른 의미를 위한 코드도 언제나 함께하니 메모리도 많이 사용한다.
    - 새로운 의미/태그 값을 추가할 때마다 모든 switch 문을 찾아 새 의미를 처리하는 코드를 추가해야 하는데, 하나라도 빠뜨리면 역시 런타임에 문제가 불거져 나올 것이다.
    - 마지막으로, 인스턴스의 타입만으로는 현재 나타내는 의미를 알 길이 전혀 없다.
- 한마디로 태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다.
- 태그 달린 클래스는 클래스 계층구조르 ㄹ어설프게 흉내낸 것이다.
- 핵심 정리
    - 태그 달린 클래스를 써야 하는 상황은 거의 없다.
    - 새로운 클래스를 작성하는 데 태그 필드가 등장한다면 태그를 없애고 계층구조로 대체하는 방법을 생각해보자.
    - 기존 클래스가 태그 필드를 사용하고 있다면 계층 구조로 리팩토링 하는 것을 고민해보자.

---
---

## Item 24. 멤버 클래스는 되도록 static으로 만들자.

### 중첩 클래스란 다른 클래스 안에 정의된 클래스를 말한다.

- 중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 외의 쓰임새가 있다면 톱레벨 클래스로 만들어야 한다.
- 중첩 클래스의 종류는
    - 정적 멤버 클래스,
    - (비정적) 멤버 클래스
    - 익명 클래스
    - 지역 클래스 이렇게 네 가지가 있다.
- 이 중 정적 멤버 클래스를 제외한 나머지는 내부 클래스에 해당한다.

### 정적 멤버 클래스

- 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스와 똑같다.
- 정적 멤버 클래스는 흔히 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰인다.
- 예를 들어 Operation 열거 타입은 Calculator 클래스의 멤버로 public static class 가 되어야 한다.

### 비정적 멤버 클래스

- 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다. 그래서 this를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있다.
- 정규화된 this란 ```클래스명.this``` 형태로 바깥 클래스의 이름을 명시하는 용법을 말한다.
- 따라서 개념상 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 한다.
- 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없다.
- 보통 바깥 클래스의 인스턴스 메서드에서 비정적 멤버 클래스의 생성자를 호출할 때 자동으로 만들어지는게 보통이지만,
    - 드물게는 [바깥 인스턴스 클래스].new MemberClass(args)를 호출해 수동으로 만들기도 한다.
- 비정적 멤버 클래스는 어댑터를 정의할 대 자주 쓰인다.
- 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static 을 붙여서 정적 멤버 클래스로 만들자.

### 익명 클래스

- 익명클래스는 이름이 없으며, 바깥 클래스의 멤버도 아니다.
- 멤버와 달리 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다.
- 응용하는 데 제약이 많은 편이다.
- 선언한 지점에서만 인스턴스를 만들 수 있고, instanceof 검사나 클래스의 이름이 필요한 작업은 수행할 수 없다.
- 여러 인터페이스를 구현할 수 없고 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수도 없다.
- 람다 식을 지원하기 이전에 작은 함수 객체나 처리 객체를 만드는 데 익명 클래스를 주로 사용해왔으나 이제는 람다를 사용하자.
- 익명 클래스의 또 다른 주 쓰임은 정적 팩터리 메서드를 구현할 때다.

### 지역 클래스

- 네 가지 중첩 클래스는 가장 드물게 사용된다.
- 지역 클래스는 지역변수를 선언할 수 있는 곳이면 실질적으로 어디서든 선언할 수 있고, 유효 범위도 지역변수와 같다.
- 다른 세 중첩 클래스와의 공통점도 하나씩 가지고 있다.
- 멤버 클래스처럼 이름이 있고 반복해서 사용할 수 있다.
- 익명 클래스처럼 비정적 문맥에서 사용될 때만 바깥 인스턴스를 참조할 수 있으며, 정적 멤버는 가질 수 없으며, 가독성을 위해 짧게 작성해야 한다.

### 핵심 정리

- 중첩 클래스에는 네 가지가 있으며, 각각 쓰임이 다르다.
- 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 멤버 클래스로 만든다.
- 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적으로
    - 그렇지 않으면 정적 클래스로 만들자.
- 중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명 클래스로 만들고
    - 그렇지 않으면 지역 클래스로 만들자.

---
---

## Item 25. 톱레벨 클래스는 한 파일에 하나만 담으라

- 소스 파일 하나에 톱레벨 클래스를 여러 개 선언하더라도 자바 컴파일러는 불평하지 않는다.
- 하지만 아무런 득이 없을 뿐더러 심각한 위험을 감수해야 하는 행위다.
- 이렇게 하면 한 클래스를 여러 가지로 정의할 수 있으며, 그중 어느 것을 사용할지는 어느 소스 파일을 먼저 컴파일하냐에 따라 달라지기 때문이다.
- 해결책은 아주 간단하며, 단순히 톱레벨 클래스들을 서로 다른 소스 파일로 분리하면 그만이다.
- 그리고 다른 클래스에 딸린 부차적인 클래스라면 정저거 멤버 클래스로 만드는 쪽이 일반적으로 더 나을 것이다.
    - 읽기 좋고 private으로 선언하면 접근 범위도 최소로 관리할 수 있기 때문이다.
- 핵심 정리
    - 교훈은 명확하다. 소스파일 하나에는 반드시 톱레벨 클래스를(혹은 톱레벨 인터페이스)를 하나만 담자.
    - 이 규칙만 따른다면 한 클래스에 대한 정의를 여러 개 만들어내는 일은 사라진다.
    - 소스 파일을 어떤 순서로 컴파일하든 바이너리 파일이나 프로그램의 동작이 달라지는 일은 결코 일어나지 않을 것이다.


















