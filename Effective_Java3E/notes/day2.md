# 2. Day 2. 객체의 파괴 / Item 6~9


##Item 6. 불피룡한 객체 생성을 피하라

똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다. 재사용은 빠르고 세련되다. 특히 불변 객체는 언제든 재사용할 수 있다.

```java
String s = new String("binikin");
```

위 문장은 실행될 때마다 String 인스턴스를 새로 만든다. 이 문장이 반복문이나 빈번히 호출되는 메서드 안에 있다면 쓸데없는 String 인스턴스가 수백만 개 만들어질 수도 있다. 개선된 버전을 보자.

```
 String s = "bikini";
```

이 방식을 사용한다면 같은 가상 머신안에서 이와 똑같은 문자열 리터럴을 상숑하는 모든 코드가 같은 객체를 재사용함이 보장된다.

- 생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스에서는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.
- 예컨데 ```Boolean(String)``` 생성자 대신 ```Boolean.valueOf(String)``` 팩토리 메서드를 사용하는 것이 좋다.
- 생성자는 호출할 때마다 새로운 객체를 만들지만, 팩터리 메서드는 전혀 그렇지 않다.
- 객체가 불변이라면 재사용해도 안전함이 명백하다. 하지만 훨씬 덜 명확하거나, 심지어 직관에 반대되는 상황도 있다.
 
### 어댑터를 생각해보자.
- 어댑터는 실제 작업은 뒷단 객체에 위임하고, 자신은 제2의 인터페이스 역할을 해주는 객체다.
- 어댑터는 뒷단 객체만 관리하면 된다.
- 즉 뒷단 객체 외에는 관리할 상대가 없으므로 뒷단 객체 하나당 어댑터 하나씩만 만들어지면 충분하다.
- 불필요한 객체를 만들어내는 또 다른 예로 오토박싱을 들 수 있다.
- 오토 박싱은 기본 타입과 그에 대응하는 박싱된 기본타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.
- 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.


-----
---


## Item 7 다 쓴 객체 잠조를 해제하라.


- 가비지 컬렉션 언어에서는 (의도치 않게 객체를 살려두는) 메모리 누수를 찾기가 아주 까다롭다.
- 객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체뿐아니라 그 객체가 참조하는 모든 객체를 회수해 가지 못한다.
- 그래서 단 몇 개의 객체가 매우 많은객체를 회수되지 못하게 할 수 있고 잠재적으로 성능에 악영향을 줄 수 있다.
- 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.
- 다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 스코프 밖으로 밀어내는 것이다.
- 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다.
- 캐시 역시 메모리 누수를 일으키는 주범이다.


## Item 8. finalizer와 cleaner 사용을 피하라.

- 자바는 두 가지 객체 소멸자를 제공한다.
- ```finalizer```는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.
- ```clener```는 ```finalize```r 보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.
- 상태를 영구적으로 수정하는 작업에서는 절대 ```finalizer```나 ```cleaner```에 의존해서는 안 된다.
    - 예를 들어 데이터베이스 같은 공유 자원의 영구락 해제를 ```finalizer```나 ```cleaner```에 맡겨 놓으면 분산 시스템 전체가 서서히 멈출 것이다.
- ```System.gc```. 나 ```System.runFinalization``` 메서드에 현혹되지 말자.
- ```finalizer```와 ```cleaner```가 실행될 가능성을 높여줄 수는 있으나, 보장해주진 않는다.
- ```finalizer```와 ```clener```는 심각한 성능 문제도 동반한다. 이들은 가비지 컬렉터의 효율을 떨어뜨리기 때문이다.
- ```finalizer```를 사용한 클래스는 ```finalizer ```공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.
- 객체 생성을 막으려면 생성자에서 예외를 던지는 것만으로 충분하지만, ```finalizer```가 있다면 그렇지도 않다.
- ```final``` 이 아닌 ```finalizer``` 공격으로부터 방어하려면 아무일도 하지 않는 ```finalize```메서드를 만들고 ```final```로 선언하자.
- 파일이나 스레드 등 종료해야 할 자원을 담고있는 객체의 클래스에서 ```finalizer```나 ```cleaner```를 대신해줄 묘안은 무엇일까?
- 그저 ```AutoCloseable```을 구현해주고 클라이언트에서 인스턴스를 다 쓰고 나면 ```close ```메서드를 호출하면 된다. (일반적으로 예외가 발생해도 제대로 종료되도록 ```try-with-resource```를 사용해야한다.)


----

## Item9. try-finally 보다는 try-with-resources를 사용하라.


아래 구조를 사용하려면 해당 자원이 ```AutoCloseable``` 인터페이스를 구현해야한다.

```java
static String firstLineOfFile(String path, String defaultVal) {
        try (
                FileReader fileReader = new FileReader(path);
                BufferedReader br = new BufferedReader(fileReader)
        ) {
            return br.readLine();
        } catch (IOException e) {
            return defaultVal;
        }
    }
```


















