# Day 13. 예외 / Item 69~77

## Item 69 예외는 진짜 예외 상황에만 사용하라.

1. 예외는 예외 상황에 쓸 용도로 설계되었으므로, JVM 구현자 입장에서는 명확한 검사만크 ㅁ빠르게 만들어야 할 동기가 약하다 (최적화에 별로 신경을 쓰지 않았을 가능 성이 크다)
2. 코드를 try-catch 블록 안에 넣으면 JVM 이 적용할 수 있는 최적화가 제한된다.
3. 배열을 순회하는 표준 관용구는 앞서 걱정한 중복검사를 수행하지 않는다. JVM이 알아서 최적화해 없애준다.

- 예외는 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안된다.
- 잘 설계된 API 라면 클라이언트가 정상적인 흐름에서 예외를 사용할 일이 없게 되야 한다.

### 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택 하는 지침

- 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다.
    - 상태 검사 메서드와 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문이다.
- 성능이 중요한 상황에서 상태 검사 메서드가 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
- 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다.
    - 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 쉽다.
    - 상태 검사 메서드 호출을 깜빡 잊엇따면 상태 의존적 메서드가 예외를 던져 버그를 확실히 드러낼 것이다. 반면 특정 값은 검사하지 않고 지나쳐도 발견하기가 어렵다 (옵셔널에는 해당하지 않는 문제다).

### 핵심 정리

- 예외는 예외 상황에서 쓸 의도로 설계되었다.
- 정상적인 제어 흐름에서 사용해서는 안되며, 이를 프로그래머에게 강요하는 API 를 만들어서도 안된다.

-----
-----

## Item 70 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라.

- 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라
- 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.
- 우리가 구현하는 비검사 throwable은 모두 RuntimeException 의 하위 클래스여야 한다.
    - AssertionError를 제외한 모든 에러는 상속하면 안되며, throw문으로 직접 던지는 일도 없어야 한다.

### 핵심 정리

- 복구할 수 있는 상황이면 검사 예외를,
- 프로그래밍 오류라면 비검사 예외를 더닞자.
- 확실하지 않다면 비검사 예외를 던지자.
- 검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의하지도 말자.
- 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.


-----
-----


## Item 71 필요 없는 검사 예외 사용은 피하라.

- 검사 예외가 프로그래머에게 지우는 부담은 메서드가 단 하나의 검사 예외만 던질 때가 특히 크다.
    - 이미 다른 검사 예외도 던지는 상황에서 또 다른 검사 예외를 추가하는 경우라면 기껏해야 catch 문 하나 추가하는 선에서 끝이다.
    - 하지만 검사 예외가 단 하나 뿐이라면 오직 그 예외 때문이 API 사용자는 try catch 블록을 추가하고 스트림에서 직접 사용하지 못하게 된다.
- 검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다. 대신 그만큼 예외에 대한 부가정보를 담을 수 가 없다.

### 핵심 정리

- 꼭 필요한 곳에만 사용한다면 검사 에외는 프로그램의 안정성을 높여주지만, 남용하면 쓰기 고통스러운 API 를 낳는다.
- API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.
- 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자.
- 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.


-----
-----


## Item 72. 표준 예외를 사용하라.

- 숙련된 프로그래머는 그렇지 못한 프로그래머보다 더 많은 코드를 재사용한다.
- 표준 예외를 사용하면 다른 사람이 익히고 사용하기 쉬워진다는 것이다.
- Exception , RuntimeException, THrowable, Error 는 직접 재사용하지 말자. 이 예외들은 추상 클래스라고 생각하길 바란다.


-----
-----


## Item 73 추상화 수준에 맞는 예외를 던지라.

- 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다. 이를 예외 번역이라고 한다.
- 예외를 번역할 때 저수준 예외가 디버깅에 도움이 된다면 예외 연쇠를 사용하는게 좋다.
- 예외 연쇄란 문제의 근본 원인인 저수준예외를 고수준예외에 실어보내는 방식이다.
    - 그러면 별도의 접근자 메서드를 통해 피룡하면 언제든 저수준 예외를 꺼내볼수있다.
    - 고수준 예외의 생성자는 상위 클래스의 생성자에 이'원인'을 건내주어, 최종적으로Throwable생성자 까지 건네지게 한다.
- 무턱대고 예외를 전파하는 것보다야 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 곤란하다.
- 차선책으로 아래 계층에서의 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하여 문제를 클라이언트에게 전파하지 않는 방법이 있다. 이경우 적절한 로깅 기능을 활용하여 기록해두면 좋다.
 

### 핵심 정리
- 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라.
- 이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다. 아이템(75)


-----
-----

## Item 74. 메서드가 던지는 모든 예외를 문서화하라.

- 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws태그를 사용하여 정확히 문서화하자.
    - 극단적이 ㄴ예로 메서드가 Exception이나 THrowable을 던진다고 선언해서는 안된다.
- 비검사 예외도 검사 예외처럼 정성껏 문서화 해두면 좋다.
    - 자신이 일으킬 수 있는 오류들이 무엇인지 알려주면 프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩하게 된다.
    - 잘 정비된 비검사 예외 문서는 사실상 그 메서드를 성공적으로 수행하기 위한 전제 조건이 된다.
- 발생 가능한 비검사 예외를 문서로 남기는 일은 인터페이스 메서드에서 특히 중요하다. 이 조건이 인터페이스의 일반 규약에 속하게 되어 그 인터페이스를 구현한 모든 구현체가 일관되게 동작하도록 해주기 때문이다.
- 메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.
- 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 (각각의 메서드가 아닌) 클래스 설명에 추가하는 방법도 있다. NullPointerException이 가장 흔한 사례다.

### 핵심 정리
- 메서드가 던질 가능성이 있는 모든 예외를 문서화하라.
- 검사 예외든 비검사 예외든, 추상 메서드든 구체 메서드든 모두 마찬가지다.
- 문서화에는 자바독의 @throws 태그를 사용하면 된다.
- 검사 예외만 메서드 선언의 throws문에 일일이 선언하고, 비검사 예외는 메서드 선언에는 기입하지 말자.
- 발생 가능한 예외를 문서로 남기지 않으면 다른 사람이 그 클래스나 인터페이스를 효과적으로 사용하기어렵거나 심지어 불가능 할 수 있다.

-----
-----

## Item 75 예외의 상세 메시지에 실패 관련 정보를 담으라.

- 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다.
    - 예를 들어 IndexOutOfBoundsException은 범위의 최솟값과 최댓값, 범위를 벗어난 인덱스 값을 담아야 한다.
    - 보안과 관련한 정보는 주의해서 담는다.
- 예외의 상세 메시지와 최종 사용자에게 보여줄 오류메시지를 혼동해서는 안된다.
    - 최종사용자에게는 친절한 안내 메시지를 보여줘야 하는 반면,
    - 예외 메시지느 ㄴ가독성보다는 담긴 내용이 훨씬 중요하다.
- 아이템 70에서도 제안하였듯, 예외는 실패와 관련한 정보를 얻을 수 있는 접근자 메서드를 적절히 제공하는 것이 좋다.

-----
-----

## Item 76 가능한 한 실패 원자적으로 만들라.

- 일반화해 이야기하면, 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다.
    - 이러한 특성을 실패 원자적 failure-atomic 이라고 한다.
- 메서드를 실패 원자적으로 만드는 방법은 다양하다.
    - 가장 간단한 방법은 불변 객체로 설계하는 것이다.
    - 불변객체는 태생적으로 실패 원자적이다.
    - 메서드가 실패하면 새로운 객체가 만들어지지는 않을 수 있으나 기존 객체가 불안정한 상태에 빠지는 일은 결코 없다.
    - 이와 비슷한 취지로 실패할 가능성이 있는 모든 코드를, 객체의 상태를 바꾸는 코드보다 앞에 배치하는 방법도 있다.
    - 계산을 수행해보기 전에는 인수의 유효성을 검사해볼 수 없을 때 앞서의 방식에 덧붙여 쓸 수 있는 기법이다.
    - 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 것이다.
    - 데이터를 임시 자료구조에 저장해 작업하는 게 더 빠를 때 적용하기 좋은 방식이다.
    - 마지막으로 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법이다.
    - 주로 디스크 기반의 내구성을 보장해야 하는 자료 구조에 쓰이는데 자주 쓰이지는 않는다.


-----
-----

## Item 77 예외를 무시하지 말라.

- catch 블록을 비워두면 예외가 존재할 이유가 없어진다.
- 예외를 무시하기로 했다면 catch블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외변수의 이름도 ignored로 바꿔놓도록하자.
