# Day 6. Generic 으로 만들어 사용하기 / Item 26~29

---
---

## Item 26. Raw 타입은 사용하지 말라.

- 용어정리
    - 클래스와 인터페이스 선언에 타입 매개변수가 쓰이면 이를 제네릭 클래스, 제네릭 인터페이스라고 한다.
    - 예를들어 List 인터페이스는 원소의 타입을 나타내는 타입 매개변수 E를 받는다. List<E>
- 각각의 제네릭 타입은 일련의 매개변수화 타입으 ㄹ정의한다.
- Raw 타입을 쓰는걸 언어 차원에서는 막아놓지는 않았지만 절대로 써서는 안된다.
    - ex) List<E> 또는 List<String> 가 아닌 List 가 Raw타입이다.
    - 로 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다.
- 로타입 사용금지에도 예외가 있다.
    - class 리터럴에는 로 타입을 써야 한다.
    - instanceof 연산자와 관련해서, 런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.

### 핵심정리

- 로 타입으 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안 된다.
- 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.
- 빠르게 훑어보자면,
    - Set<Object>는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이고,
    - Set<?> 는 모종의 타입 객체만 저장할 수 있는 와일드카드 타입이다.
    - 그리고 이들의 로 타입인 Set은 제네릭 타입 시스템에 속하지 않는다.
- Set<Object>와 Set<?>는 안전하지만, 로 타입인 Set은 안전하지 않다.

---
---

## Item 27.

### 핵심 정리

- 비검사 경고는 중요하니 무시하지 말자.
- 모든 비검사 경고는 런타임에 ClassCastException을 일으킬 수 있는 잠재적 가능성을 뜻하니 최선을 다해 제거하라.
- 경고를 없앨 방법을 찾지 못하겠다면, 그 코드가 타입 안전함을 증명하고 가능한 한 범위를 좁혀 @SupressWarnings("unchecked") 애터테이션으로 경고를 숨겨라.
- 그런 다음 경고를 숨기기로 한 근거를 주석으로 남겨라.

---
---

## Item 28. 배열보다는 리스트를 사용하라.

### 배열과 제네릭 타입에는 중요한 차이가 두 가지 있다.

- 첫째, 배열은 공변이다. Sub[.] 배열은 Super[]의 하위 타입이 된다.반면 제네릭은 불공변이다. List<Type1>  과 List<Type2> 는 하위타입도, 상위 타입도 아니다.
- 둘째, 배열은 실체화 된다.
    - 배열은 런타임에도 자신이 담기로한 원소의 타입을 인지하고 확인한다. 핵심정리
- 배열과 제네릭에는 매우 다른 타입 규칙이 적용된다.
    - 배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 소거된다.
- 그 결과 배열은 런타임에는 타입 안전하지만 컴파일타임에는 그렇지 않다. 제네릭은 반대다. 그래서 둘을 섞어 쓰기란 쉽지 않다.

---
---

## Item 29. 이왕이면 제네릭 타입으로 만들라.

### 타입 매개변수에 제약을 두는 제네릭 타입도 있다. 예컨데 java.util.concurrent.DelayQueue는 다음처럼 선언되어 있다.

```
class DelayQueue<E extends Delayed> implements BlockingQueue<E>
```

### 핵심정리

- 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다.
- 그러니 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 하라.
- 그렇게 하려면 제네릭 타입으로 만들어야 할 경우가 많다.
- 기존 타입 중 제네릭이었어야 하는 게 있다면 제네릭 타입으로 변경하자.
- 기존 클라이언트에는 아무 영향을 주지 않으면서, 새로운 사용자를 훨씬 편하게 해주는 길이다. k
















