# Day 15. Serialize, 제대로 알고 쓰기 / Item 85~90


---
---


## Item 85 자바 직렬화의 대안을 찾으라.

> "자바의 역직렬화는 명백하고 현존하는 위험이다. 이 기술은 지금도 애플리케이션에서 직접 혹은, 자바 하부시스템을 통해 간접적으로 쓰이고 있기 때문이다. 신뢰할 수 없는 스트림을 역직렬화하면 원격 코드 실행, 서비스 거부 등의 공격으로 이어질 수 있다. 잘못한 게 아무것도 없는 애플리케이션이라도 이런 공격에 취약해질 수 있다.

- 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.
- 여러분이 작성하는 새로운 시스템에서 자바 직렬화를 써야 할 이유는 전혀 없다.
- 자바 직렬화 대안으로 크로스-플랫폼 구조화된 데이터 표현 JSON과 프로토콜 버퍼다.
    - JSON 은 더글라스 크록퍼드가 브라우저와 서버의 통신용으로 설계했고
    - 프로토콜 버퍼는 구글이 서버 사이에 데이터를 교환하고 저장하기 위해 설계했다.
- 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는다. 특히 신뢰할 수 없는 발신원으로부터.
- 직렬화를 피할 수 없고 안전한지 확신하루 수 없다면 객체 역직렬화 필터링을 사용하자.
    - 데이터 스트림이 역직렬화되기 필터링을 사용하는 방법이다.
    - 클래스 단위로 특정 클래스를 받아들이거나 거부할 수 잇다.
     
 ### 핵심 정리
- 직렬화는 위험하니 피해야 한다.
- 시스템을 밑바닥부터 설계한다면 JSON 이나 프로토콜 버퍼 같은 대안을 사용하자.
- 신뢰할수 없는 데이터는 역 직렬화하지말자
-  꼭 해야 한다면 객체 역직렬화 필터링을 사용하되, 이마저도 모든 공격을 막아줄 수느 없음을 기억하자.
- 클래스가 직렬화를 지원하도록 만들지 말고, 꼭 그렇게 만들어야 한다면 정말 신경 써서 작성해야 한다.


-----
-----


## Item 86. Serializable을 구현할지는 신중히 결정하라.

S어떤 클래스의 인스턴스를 직렬화할 수 있게 하려며 ㄴ클래스 선언에 ```implements Serializable```만 덧붙이면 된다.

### Serailzable 구현의 문제점
- Serializable 을 구현하면 릴리즈한 뒤에는 수정하기 어렵다.
- Serializable 구현의 두 번재 문제는 버그와 보안 구멍이 생길 위험이 높아진다는 점이다.
- Serializable 구현의 세 번째 문제는 해당 클래스의 신버전을 릴리즈 할때 테스트 할 것이 늘어난다는 점이다.
- Serializable 구현 여부는 가볍게 결정할 사안이 아니다.

- 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안되며 인터페이스도 대부분 Serializable을 확장해서는 안된다.
- 내부 클래스는 직렬화를 구현하지 말아야 한다.
- Serializalbe을 구현한다고 선언하기는 아주 쉽지만 그저 눈속임일 뿐이다.
- 한 클래스의 여러 버전이 상호작용할 일이 없고 서버가 신뢰할 수 없는 데이터에 노출될 가능성이 없는 등, 보호된 환경에서만 쓰일 클래스가 아니라면 Serializable 구현은 아주 신중하게 이뤄져야 한다.
- 상속할 수 있는 클래스라면 주의사항이 더욱 많아진다.

-----
-----


## Item 87. 커스텀 직렬화 형태를 고려해보라.

- 먼저 고민해보고 괜찮다고 판단될때만 기본 직렬화 형태를 사용하라.
- 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.
- 기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.
- 객체의 물리적 표현과 논리적 표현의 창가 클 때 기본 직렬화 형태를 사용하면 크게 네 가지 면에서 ㅁ누제가 생긴다.
    - 1. 공개 API 가 현재의 내부 표현 방식에 영구히 묶인다.
    - 2. 너무 많은 공간을 차지할 수 있다.
    - 3. 시간이 너무 많이 걸릴 수 있다.
    - 4. 스택 오버플로를 일으킬 수 있다.
- 해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 transient 한정자를 생략해야 한다.
    - 그래서 커스텀 직렬화 형태를 사용한다면 대부분의 (혹은 모든) 인스턴스 필드를 transient로 선언해야 한다.
    - 객체의 전체 상태를 읽는 메서드에 적용해야 하나는 동기화 메커니즘을 젝렬화에도 적용해야 한다.
- 어떤 직렬화 형태를 택하는 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.
- 구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID를 절대 수정하지 말자.
 

### 핵심 정리
- 클래스를 직렬화하기로 했다면 어떤 직렬화 형태를 사용할지 심사숙고하기바란다.
- 자바의 기본 직렬화 형태는 객체를 직렬화한 결과가 해당 객체의 논리적 표현에 부합할 때만 사용하고, 그렇지 않으면 객체를 적절히 설명하는 커스텀 직렬화 형태를 고안하라.
- 직렬화 형태도 공개 메서드를 설계할 대에 준하는 시간을 들여 설계 해야 한다.
- 한번 공개된 메서드는 향후 릴리스에서 제거할 수 없듯이, 직렬화 형태에 포함된 필드도 마음대로 제거할 수 없다.
- 직렬화 호환성을 유지하기 위해 영원히 지원해야 하는 것이다.
- 잘못된 직렬화 형태를 선택하면 해당 클래스의 복잡성과 성능에 영구히 부정적인 영향을 남긴다.


-----
-----


## Item 88 readObject 메서드는 방어적으로 작성하라.

- 객체를 역질렬화 할 때는 클라이언트가 소유해서는 안되는 객체 참조를 갖는 필드를 모두 반드시 방어적으로 복사해야 한다.
 
### 핵심 정리
- readObject메서드를 작성할 때는 언제나 public생성자를 작성하는 자세로 임해야 한다.
- readObject는 어떤 바이트 스트림이 넘어오더라도 유효한 인스턴스를 만들어내야 한다.
- 바이트 스트림이 진짜 직렬화된 인스턴스라고 가정해서는 안 된다.
- 이번 아이템에서는 기본 직렬화 형태를 사용한 클래스를 예로 들었지만 커스텀 직렬화를 사용하더라도 모든 문제가 그대로 발생할 수 있다. 이어서 안전한 readObject 메서드를 작성하는 지침을 요약해보았다.
    - private 이어야 하는 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사하라. 불변 클래스 내의 가변 요소가 여기 속한다.
    - 모든 불변식을 검사하여 어긋나는게 발견되면 InvalidObjectException을 던진다.방어적 복사 다음에는 반드시 불변식 검사가 뒤따라야 한다.
    - 역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 ObjectInputValidation 인터페이스를 사용하라.
    - 직접적이든 간접적이든, 재정의할 수 있는 메서드는 호출하지 말자.
     

-----
-----


## Item 89 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라.

- 사실 readResolve를 인스턴스 통제 목적으로 사용한다면 객체 참조타입 인스턴스 필드는 모두 transient로 선언해야 한다.
- readResolve 메서드의 접근 성은 매우 중요하다. final 클래스에서라면 readResolve 메서드는 private이어야 한다. final 이 아닌 클래스에서는 다음의 몇가지를 주의해서 고려해야 한다.
    - private 으로 선언하면 같은 패키지에 속한 하위 클래스에서만 사용할 수 있다.
    - protected나 public으로 선언하면 이를 재정의하지 않은 모든 하위 클래스에서 사용할 수 있다.
    - protected나 public 이면서 하위 클래스에서 재정의하지 않았다면, 하위 클래스의 인스턴스를 역직렬화하면 상위 클래스의 인스턴스를 생성하여 ClassCastException을 일으킬 수 있다.
     
### 핵심 정리
- 불변식을 지키기 위해 인스턴스를 통제해야 한다면 가능한 한 열거 타입을 사용하자.
- 여의치 않은 상황에서 직렬화와 인스턴스 통제가 모두 필요하다면 readResolve메서드를 작성해 넣어야 하고, 그 클래스에서 모든 참조 타임 인스턴스 필드를 transient로 선언해야 한다.


-----
-----


## Item 90 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라

- Serializable을 구현하기로 결정한 순간 언어의 정상 메커니즘인 생성자 이외의 방법으로 인스턴스를 생성할 수 있게 된다.
    - 버그와 보안 문제가 일어날 가능성이 커진다는 뜻이다.
    - 이 위험을 크게줄여줄 기법이 바로 직렬화 프록시 패턴이다.
     
### 직렬화 프록시 패턴은
- 먼저, 바깥 클래스의 논리적 상태를 정밀하게 표현하는 중첩 클래스를 설계해 private static으로 선언한다.
- 이 중첩 클래스가 바로 바깥 클래스의 직렬화 프록시다.
- 중첩 클래스의 생성자는 단 하나여야 하며, 바깥 클래스를 매개변수로 받아야 한다.
- 이 생성자는 단순히 인수로 넘어온 인스턴스의 데이터를 복사한다.
- 일관성 검사나 방어적 복사도 필요 없다.
- 설계상, 직렬화 프록시의 기본 직렬화 형태느 ㄴ바깥 클래스의 직렬화 형태로 쓰기에 이상적이ㅏㄷ.
- 그리고 바깥 클래스와 직렬화 프록시 모두 Serializable을 구현해야 한다고 선언해야 한다.
   
### 직렬화 프록시 패턴의 한계는
- 첫 번째, 클라이언트가 멋대로 확장할 수 있는 클래스에는 적용할 수 없다.
- 두 번재, 객체 그래프에 순환이 있는 클래스에도 적용할 수 없다.
    - 이런 객체의 메서드를 직렬화 프록시의 readResolve 안에서 호출하려 하면 ClassCastException이 발생할 것이다.
    - 직렬화 프록시만 가졌을 뿐 실제 객체는 아직 만들어진 것이 아니기 때문이다.
- 마지막으로 직렬화 프록시패턴이 주는 강력함과 안정성에도 댓가는 따른다. 프로그램이 느려진다.
 
### 핵심 정리

- 제3자가 확장할 수 없는 클래스라면 가능한 한 직렬화 프록시 패턴을 사용하자.
- 이 패턴이 아마도 중요한 불변식을 안정적으로 직렬화해주는 가장 쉬운 방법일 것이다.






















