# Day 3. 습관적으로 사용할 수 있는 Object의 공통 메서드 / Item 10~14 


----

## Item 10. equals 는 일반 규약을 지켜 재정의하라.

#### equals가 다음에서 열거한 상황 중 하나에 해당한다면 재정의하지 않는 것이 최선이다.

- 각 인스턴스가 본질적으로 고유하다.
    - 값을 표현하는 객체가 아니라 동작하는 개체를 표현하는 클래스가 여기 해당한다. Thread가 좋은 예로, Object의 equals 메서드는 이러한 클래스에 딱 맞게 구현되었다.
- 인스턴스의 '논리적 동치성'을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
 

#### 양질의 equals 메서드 구현 방법을 단계별로 정리하기.

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
    1. 자기 자신이면 true를 반환한다. 이는 단순 한 성능 최적화용으로, 비교 작업이 복잡한 상황일 때 값어치를 할 것이다.
2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
3. 입력을 올바른 타입으로 형변환한다.
4. 입력 객체와 자기자신의 대응되는 '핵심' 필드들이 하나씩 검사한다.



##equals를 재정의하려거든 hashcode도 재정의하라.


- equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다.
- 그렇지 않으면 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.
 

### 다음은 Object 명세에서 발췌한 규약이다.
 
- equals 비교에 사용되는 정보가 변겨오디지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashcode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
- equals(Object) 두 객체를 같다고 판단했따면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
- equals(Object) 가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요가 없다.

### 주의사항

- 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다.
- hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자. 그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계산 방식을 바꿀 수도 있다.


---
---



## Item 12. toString을 항상 재정의 하라.


- toString 을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.
- 실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.
- 포맷을 명시하든 아니든 여러분의 의도는 명확히 밝혀야 한다.


---
---



## Item 13. Clone 재정의는 주의해서 진행하라.


- 사실 clone 기능을 제대로 사용하는 유일한 예로는 배열이다. 
- Cloneable이 몰고 온 모든 문제를 되짚어봤을 때, 새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안 되며, 새로운 클래스도 이를 구현해서는 안 된다. 
- final 클래스라면 CLoneable을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야 한다. 
- 기본 원칙은 '복제 기능은 생성자의 팩토리를 이용하는게 최고'라는 것이다. 
- 단 배열만은 clone 메서드 방식이 가장 갈끔한, 이 규칙의 합당한 예외라 할 수 있다.



---
---


## Item 14. Comparable을 구현할지 고려하라.


- 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여, 그 인스턴스들을 쉽게 정렬하고, 검색하고 비교 기능을 제공하는 컬렉션과 어우러지도록 해야한다.

















