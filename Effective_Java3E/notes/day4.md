# Day 4. 클래스와 인터페이스, 상속. / Item 15~19

---
---


## Item 15. 클래스와 멤버의 접근 권한을 최소화하라.


- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API 를 깔끔히 분리한다.
- 오직 API 를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.
- 정보 은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어의 근간이 되는 원리다.
- 정보 은닉의 장점은 정말 많다. 그중 대부분은 시스템을 구성하는 컴포넌트들을 서로 독립시켜서 개발, 테스트, 최적화, 적용, 분석, 수정을 개별적으로 할 수 있게 해주는 것과 연관되어 있다.
- 기본원칙은 간단하다. 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
- public 가변 필드를 갖는 클래스는 일반적으로 스레드 세이프하지 않다.
 
###핵심 정리
- 프로그램 요소의 접근성으 ㄴ가능한 한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API 를 설계하자.
- 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API 로 공개되는 일이 없도록 해야 한다.
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다.
- public static final 필드가 참조하는 개체가 불변인지 확인하라.


---
---



## Item 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.


- 패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다. (getter & setter)
- 하지만 package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다.

### 핵심 정리

- public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다.
- 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.
- 하지만 package-private 클래스나 private 중첩 클래스에서는 (불변이든 가변이든) 필드를 노출하는 편이 나을 때도 있다.


---
---


## Item 17. 변경 가능성을 최소화하라


> 불변 클래스란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스다.
> 
> 불변 클래스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다. 
> 
> 자바 플랫폼 라이브러리에도 다양한 불변 클래스 가 있다.

### 클래스를 불변으로 만들려면 다음 다섯 가지 규칙을 따르면 된다.

1. 객체의 상태를 변경하는 메서드(변경자, setter)를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
3. 모든 필드를 final 로 선언한다.
4. 모든 필드를 private으로 선언한다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

### 핵심 정리
- 불변객체는 생성된 이후 상태가 변하지 않는다.
- 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다. 그래서 안심하고 공유할 수 있다.
- 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.
- 불변 객체는 그 자체로 실패 원자성을 제공한다.
- 불변 클래스에도 단점은 있다. 값이 다르면 반드시 독립된 객체로 만들어야한다는 것이다.
- getter 가 있다고 해서 무조건 setter 를 만들지 말자.
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다. 불변 클래스는 장점이 많으며 단점이라곤 특정 상황에서의 잠재적 성능 저하뿐이다.
- 모든 클래스가 불변일 수는 없지만 변경할 수 있는 부분을 최소한으로 줄이자.
- 다른 합당한 이유가 없다면 모든 필드는 private final 이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.


---
---



## Item 18. 상속보다는 컴포지션을 사용하라.


- 상속은 코드를 재사용하는 강력한 수단이지만, 항상 최선은아니다.
- 여기서 상속은 인터페이스를 구현하는 상속이 아닌 확장 extends 하는 상속을 의미한다.
- 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.
- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다. is-a 관계일 때만 말이다.
 
 

###핵심 정리
- 상속은 강력하지만 캡슐화를 해친다는 문제가 있다.
- 상속은 상위클래스와 하위클래스가 순수한 is-a 관계일 때만 써야한다.
- is-a 관계일 때도 안심할 수만은 없는게, 하위클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다.
- 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.
- 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다.
- 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.

---
---



## Item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라


- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 (자기사용) 문서로 남겨야 한다.
- 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 hook을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
- 드물게는 protected 필드로 공개해야 할 수도 있다.
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메소드를 호출해서는 안된다.
- clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메소드를 호출해서는 안 된다.
- 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당함을 알아야한다.
- 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다.
- 상속을 금지하는 방법은 두 가지다.
    - 1 final 로 선언한다
    - 2 모든 생성자를 private 이나 package-private 으로 선언하고 public 정적 팩터리를 만들어주는 방법이다.

### 핵심 정리

- 상속용 클래스를 설계하기란 결코 만만치 않다.
- 클래스 내부에서 스스로를 어떻게 사용하는지 (자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화 한것은 그 클래스가 쓰이는 한 반드시 지켜야한다.
- 그러지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 잇다.
- 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다.
    - 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것이다.
    - 상속을 금지하려면 클래스를 final 로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.
