# Day 8. Enum 과 Annotation의 Effective한 사용 / Item 34~41


----
----


## Item 34 int 상수 대신 열거 타입을 사용하라.

- 열거타입의 아이디어는 단순하다.
    - 열거타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개한다.
    - 열거 타입은 밖에서 생성자를 제공하지 않으므로 사실상 final 이다.
- 열거 타입은 컴파일타임 타입 안정성을 제공한다.
 
### 열거 타입 상수 만드는 방법은
- 열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.
- 열거타입은 근본적으로 불변이라 모든 필드는 final이어야 한다.
- 널리 쓰이는 열거 타입은 톱레벨 클래스로 만들고, 특정 톱레벨 클래스에서만 쓰인다면 해당 클래스의 멤버 클래스로 만든다.
- 예를 들어 소수 자릿수의 반올림 모드를 뜻하는 열거 타입인 java.math.RoundingMode 는 BigDecimal 이 사용한다.
- swtich 문은 열거 타입의 상수별 동작을 구현하는 데 적합하지 않다.
- 하지만 기존 열거 타입에 상수별 동작을 혼합해 넣을 대는 switch 문이 좋은 선택이 될 수 있다.
 

### 열거 타입을 사용하는 때는?
- 필요한 원소를 컴파일 타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자.
- 열거 타입에 정의된 상수 개수가 영원히 고정 불변일 필요는 없다.
 

### 핵심 정리
- 열거 타입은 확실히 정수 상수 보다 뛰어나다.
- 더 읽기 쉽고 안전하고 강력하다.
- 대다수 열거 타입이 명시적 생성자나 메서드 없이 쓰이지만, 각 상수를 특정 데이터와 연결짓거나 상수마다 다르게 동작하게 할 때는 필요하다.
- 드물게는 하나의 메서드가 상수별로 다르게 동작해야 할 때도 있따.
- 이런 열거 타입에서는 switch 문 대신 상수별 메서드 구현을 사용하자.
- 열거 타입 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 (내부 클래스로 열거 타입을 선언) 사용하자.


---
---


## Item 35 ordinal 메서드 대신 인스턴스 필드를 사용하라

- 모든 열거 타입은 해당 상수가 몇 번째 위치인지를 반환하는 ordinal() 이라는 메서드를 제공한다.
- 하지만 ordinal() 메서드를 사용한 프로그램은 동작은 하겠지만 유지보수하기가 끔찍한 코드다. ( 상수 선언 순서를 바꾸는 순간 오동작하며, 이미 사용 중이 정수와 값이 같은 상수는 추가할 방법이 없다.)
- 열거 타입 상수에 연결된 값은 ordinal 메서드로 얻지 말고 필드에 저장하자.

```java
public enum Apple{
    FIJI("FIJI"),
    ...
```

---
---


## Item 36. 비트 필드 대신 EnumSet을 사용하라

### 핵심 정리 
- 열거할 수 있는 타입을 한데 모아 집합 형태로 사용한다고 해도 비트 필드를 사용할 이유는 없다.
- EnumSet 클래스가 비트 필드 수준의 명료함과 성능을 제공하고 아이템 34에서 설명한 열거 타입의 장점까지 선사하기 때문이다.
- EnumSet의 유일한 단점이라면 (자바9까지는) 아직 불변 EnumSet을 만들 수 없다는 것이다.
- 수정되기 전가지는 Collections.unmodifiableSet으로 EnumSet을 감싸 사용할 수 있다.
         

---
---



## Item 37. ordinal 인덱싱 대신 EnumMap을 사용하라

- 배열의 인덱스를 얻기 위해 ordinal 을 쓰는 것은 일반적으로 좋지 않으니, 대신 EnumMap 을 사용하라.
- 다차원 관계는 EnumMap<..., ENumMap<...>>으로 표현하라.
- "애플리케이션 프로그래머는 Enum.ordinal 을 웬만해서는 사용하지 말아야한다"


------
----

## Item 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라.

- 열거 타입 자체는 확장할 수 없지만, 인터페이스와 그 인터페이스를 구현하는 기본 열거 타입을 함께 사용해 같은 효과를 낼 수 있다.
- 이렇게 하면 클라이언트는 이 인터페이스를 구현해 자신만의 열거 타입(혹으 ㄴ다른 타입)을 만들 수 있다.
- 그리고 API 가 (기본 열거 타입을 직접 명시하지 않고) 인터페이스 기반으로 작성되었다면 기본 열거 타입의 인스턴스가 쓰이는 모든 곳을 새로 확장한 열거 타입의 인스턴스로 대체해 사용할 수 있다.


```java
public interface Operation{
    double apply(double x, double y);
    ...
    ...

public enum BasicOperation implements Operation{
    PLUS("+"){
        public double apply(double x, double y) { return x + y; }
    ...
    ...
```

---
---


## Item 39. 명명 패턴보다 애너테이션을 사용하라.

- 자바 8에서는 여러 개의 값을 받는 애너테이션을 다른 방식으로도 만들 수 있다.
    - 배열 매개변수를 사용하는 대신 애너테이션에 @Repeatable 메타애너테이션을 다는 방식이다.
- 애너테이션이 명명 패턴 보다 낫다.
- 테스트는 애너테이션으로 할 수 있는 일 중 극히 일부일 뿐이다.
- 애너테이션으로 할 수 있는 일을 명명 패턴으로 처리할 이유는 없다.
- 자바 프로그래머라면 예외 없이 자바가 제공하는 애너테이션 타입들은 사용해야 한다.

---
---


## Item 40. @Override 애너테이션을 일관되게 사용하라.

- @Override 애너테이션을 일관되게 사용하라.
- 상위 클래스의 메서드를 제정의 하려는 모든 메서드에 @Override 애너테이션을 달자.


### 핵심 정리
- 재정의한 모든 메서드에 @Override 애너테이션을 의식적으로 달면 여러분이 실수했을 때 컴파일러가 바로 알려줄 것이다.
- 예외는 한 가지뿐이다. 구체 클래스에서 상위 클래스의 추상 메서드를 재정의한 경우엔 이 애너테이션을 달지 않아도 된다(단다고 해서 해로울 것도 없다.)


---
---


## Item 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라.


> 아무 메서드도 담고 있지 않고 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스를 마커 인터페이스라 한다.
 

#### 마커 애너테이션이 등장하면서 마커 인터페이스는 구식이 되었다는 이야기를 들어보았을것이지만 마커 인터페이스는 애너테이션보다 두가지 면에서 낫다.

1. 마커 인터페이스는 이를 구현한 클래스의 ㅇ인스턴스들을 구분하는 타입으로 쓸수 있으나, 마커 애너테이션은 그렇지 않다.
    - 마커 인터페이스는 어엿한 타입이기 때문에, 구현체들의 오류들을 컴파일 타임에 잡을 수 있다.
2. 마커 인터페이스가 나은 점 두 번째는 적용 대상을 더 정밀하게 지정할 수 있다는 것이다.
 

#### 반대로 마커 애너테이션이 인터페이스보다 나은점은
1. 거대한 애너테이션 시스템의 지원을 받는다는 점을 들 수 있다.

#### 언제 마커 인터페이스를, 언제 마커 애너테이션을 써야하는가, 만약 내가 마킹 대상 객체를 매개변수로 받는 메서드를 작성할 일이 있을까? 라는 질문에
- 그렇다 하면 마커 인터페이스를 써야 한다.
- 아니면 애너테이션을 사용한다.


### 핵심 정리
- 마커 인터페이스와 마커 애너테이션은 각자의 쓰임이 있다.
- 새로 추가하는 메서드 없이 단지 타입 정의가 목적이라면 마커 인터페이스를 선택하자.
- 클래스나 인터페이스 외의 프로그램 요소에 마킹해야 하거나, 애너테이션을 적극 활용하는 프레임워크의 일부로 그 마커를 편입시키고자 한다면 마커 애너테이션이 올바른 선택이다.
- 적용 대상이 ElementType.TYPE인 마커 애너테이션을 작성하고 있다면, 잠시 여유를 갖고 정말 애너테이션으로 구현하는게 옳은지, 혹은 마커 인터페이스가 낫지는 않을지 곰곰히 생각해보자.
- 간략하게 "타입을 정의할 거라면 인터페이스를 쓰라" 라고 해석할 수도 있다.




















