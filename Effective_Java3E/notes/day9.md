# Day 9. Lambda와 Stream / Item 42~48

---
---

## Item 42. 익명 클래스보다는 람다를 사용하라.

- 우선 람다를 직렬화 하는일은 극히 삼가야 한다.
- 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자. ( 컴파일러가 오류를 낼때만 타입을 명시하면 된다)
- 메서드나 클래스와 달리 람다는 이름이 없고 문서화도 못 한다. 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수 가 많아지면 람다를 쓰지 말아야 한다.
- 람다를 직렬화하는 일은 극히 삼가야 한다.
- 익명 클래스는 (함수영 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용하라.
- 람다는 작은 함수 객체를 표현할 때 사용하라.

---
---

## Item 43. 람다보다는 메서드 참조를 사용하라.

### 메서드 참조 유형

- 정적
    - Integer::parseInt
    - 같은 기능의 람다 ```str -> Integer.parseInt(str)
- 한정적 (인스턴스)
    - Instance.now()::isAfter
    - 같은 기능의 람다
        - Instanced then = Instance.now();
        - t -> then.isAfter(t)
- 비한정적 (인스턴스)
    - String::toLowerCase
    - 같은기능의 람다 str -> str.toLowerCase()
- 클래스 생성자
    - TreeMap<K,V>::new
    - 같은기능의 람다 () -> new TreeMap<K,V>()
- 배열 생성자
    - int[]::new
    - len -> new int[len]

### 핵심 정리

- 메서드 참조는 람다의 간단 명료한 대안이 될 수 있다.
- 메서드 참조쪽이 짧고 명확하다면 메서드 참조를 쓰고 그렇지 않을 때만 람다를 사용하라.

---
---

## Item 44. 표준 함수형 인터페이스를 사용하라.

- 자바가 람다를 지원하면서 API 를 작성하는 모범 사례도 크게 바뀌었다.
- 예컨대 상위 클래스의 기본 메서드를 재정의해 원하는 동작을 구현하는 템플릿 메서드 패턴의 매력이 크게 줄었다.
- 이를 대체하는 현대적인 해법은 같은 효과의 함수 객체를 받는 정적 팩터리나 생성자를 제공하는 것이다.
- 이 내용을 일반화해서 말하면 함수 객체를 매개변수로 받는 생성자와 메서드를 더 많이 만들어야 한다.
- 이때 함수형 매개변수 타입을 올바르게 선택해야한다.

> 필요한 용도에 맞는 게 잇다면 직접 구현하지 말고 표준 함수혀 ㅇ인터페이스를 활용하라. 그러면 API 가 다루는 개념의 수가 줄어들어 익히기 더 쉬워진다.

- 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자.
- 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하라.

### 핵심 정리

- 이제 자바도 람다를 지원한다.
- 여러분도 지금부터는 API를 설계할 때 람다도 염두에 두어야 한다는 것이다.
- 입력값과 반환값에 함수형 인터페이스 타입을 활용하라.
- 보통은 java.util.function 패키지의 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선택이다.

---
---

## Item 45. 스트림은 주의해서 사용하라

> 스트림은 다량의 처리작업 (순차적이든 병력적이든)을 돕고자 자바8에 추가되었다.

### 스트림이 API 가 제공하는 추상 개념 중 핵심은 두가지다.

1. 스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻한다.
2. 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념이다.
    - 스트림의 원소들은 어디로부터든 올 수 있따.

### 스트림 파이프라인의 구조

- 소스 스트림에서 시작해
- 종단 연산으로 끝난다.
- 그 사이에 하나 이상의 중간 연산이 있을 수 있다.(=transform)
    - 중간 연산들은 모두 한 스트림을 다른 스트림으로 변환하는데

### 스트림 API 는 메서드 연쇄를 지원하는 플루언트 API 다.

- 즉, 파이프라인 하나를 구성하는 모든 호출을 연결하여 단 하나의 표현식으로 완성할 수 있다.
- 기존 코드는 스트림을 사용하도록 리팩터링하되, 새 코드가 더 나아 보일 때만 반영하자.

### 스트림의 연산 (함수 객체와 코드 블록)

- 스트림 파이프라인은 되풀이 되는 계산을 함수 객체(주로 람다나 메서드 참조)로 표현하며 반면 반복 코드에서는 코드 블록을 사용해 표현한다..
- 그런데 함수 객체로는 할 수 없지만 코드 블록으로는 할 수 있는 일들이 있으니, 다음이 그 예다.
    - 코드 블록에서는 범위 안의 지역변수를 읽고 수정할 수 있다. 하지만 람다에서는 final 이거나 사실상 final 인 변수만 읽을 수 있고, 지역변수를 수정하는 건 불가능하다.
    - 코드 블록에서는 return 문을 사용해 메서드에서 빠져나가거나, break 나 continue 문으로 블록 바깥의 반복문을 종료하거나 반복을 한 번 건너뛸 수 있다.
    - 또한 메서드 선언에 명시된 검사 예외를 던질 수 있다.
    - 하지만 람다로 이 중 어떤 것도 할 수 없다.
- 계산 로직에서 이상의 일들을 수행해야 한다면 스트림과는 맞지 않는 것이다.

### 스트림이 적합한 경우

- 반대로 다음 일들에는 스트림이 아주 안성맞춤이다.
    - 원소들의 시퀀스를 일관되게 변환한다.
    - 원소들의 시퀀스를 필터링한다.
    - 원소들의 시퀀스를 하나의 연산을 사용해 결합한다. (더하기, 연결하기, 최솟값 구하기 등).
    - 원소들의 시퀀스를 컬렉션에 모은다. (아마도 공통된 속성을 기준으로 묶어가며)
    - 원스들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.

### 스트림으로 처리하기 어려운 일들

- 반대로 스트림으로 처리하기 어려운 일들의
- 대표적인 예로, 한 데이터가 각 단계의 값들에 동시 접근하기는 어려운 경우다.

### 핵심 정리

- 스트림을 사용해야 멋지게 할 수 있는 일이 있고, 반복 방식이 더 알맞는 일도 잇다.
- 그리고 수많은 작업이 이 둘을 조합했을 때 가장 멋지게 해결된다.
- 어느 쪽을 선택하는 확고부동한 규칙은 없지만 참고할 만한 지침 정도는 있다.
- 어느 쪽이 나은지가 확연히 드러나는 경우가 많겠지만, 아니더라도 방법은 있다.
- 스트림과 반복 중 어느쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 택하라.

---
---

## Item 46. 스트림에서는 부작용 없는 함수를 사용하라.

- 스트림은 그저 또 하나의 API 가 아닌, 함수형 프로그래밍에 기초한 패러다임이기 때문이다.
- 스트림이 제공하는 표현력, 속도, (상황에 따라서는) 병렬성을 얻으려면 API 는 말할 것도 없고 이 패러다임까지 함께 받아들여야 한다.
- 스트림 패러다임의 핵심은 계산을 일련의 변환(transformation)으로 재구성하는 부분이다.
- 이때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수함수여야 한다.
    - 순수 함수란 오직 입력만이 결과에 영향을 주는 함수를 말한다.
    - 다른 가변 상태를 참조하지 않고 함수 스스로도 다른 상태를 변경하지 않는다.
- forEach 연산은
    - 스트림 계산 결과를 보고할 때만 사용하고, 계산할 때는 쓰지 말자.
    - 가장 덜 스트림 다운 종단 연산이다.

### 핵심 정리

- 스트림 파이프라인 프로그래밍의 핵심은 부작용 없는 함수 객체에 있다.
- 스트림뿐 아니라 스트림 관련 객체에 건네지는 모든 함수 객체가 부작용이 없어야 한다.
- 종단 연산 중 forEach는 스트림이 수행한 계산 결과를 보고할 때만 이용해야 한다.
- 계산 자체에는 이용하지 말자.
- 스트림을 올바로 사용하려면 수집기를 잘 알아둬야한다.
- 가장 중요한 수집기 팩터리는
    - toList
    - toSet
    - toMap
    - groupingBy
    - joining 이다.

---
---

## Item 47. 반환 타입으로는 스트림보다 컬렉션이 낫다.

- 원소 시퀀스를 반환하는 공개 API 의 반환 타입에는 Collection 이나 그 하위 타입을 쓰는 게 일반적으로 최선이다.
- 단지 컬렉션을 반환한다는 이유만으로 덩치큰 시퀀스를 메모리에 올려서는 안된다.

### 핵심 정리

- 원소 시퀀스를 반환하는 메서드를 작성할 대는, 이를 스트림으로 처리하기를 원하는 사용자와 반복으로 처리하길 우너하는 사용자가 모두 있음을 떠올리고, 양쪽을 다 만족시키려 노력하자.
- 컬렉션을 반환할 수 있다면 그렇게 하라.
- 반환 전부터 이미 원소들을 컬렉션에 담아 관리하고 있거나 컬렉션을 하나 더 만들어도 될 정도로 원소 갯수가 적다면 ArrayList 같은 표준 컬렉션에 담아 반환하라.
- 그렇지 않으면 앞서의 멱집합 예 처럼 전용 컬렉션을 구현할지 고민하라.
- 컬렉션을 반환하는 게 불가능하면 스트림과 Iterable 중 더 자연스러운 것을 반환하라.
- 만약 나중에 Stream 인터페이스가 Iterable을 지원하도록 자바가 수정된다면, 그때는 안심하고 스트림을 반환하면 될 것이다.

---
---

## Item 48. 스트림 병렬화는 주의해서 적용하라.

- 자바 8부터는 parallel 메서드만 한 번 호출하면 파이프라인을 병렬 실행할 수 있는 스트림을 지원했다.
- 이처럼 자바로 동시성 프로그램을 작성하기가 점점 쉬워지고는 있찌만, 이를 올바르고 빠르게 작성하는 일은 여전히 어려운 자겅ㅂ이다.
- 동시성 프로그래밍을 할 때는 안정성과 응답 가능 상태를 유지하기 위해 애써야 하는데, 병렬 ㅍ스트림 파이프라인 프로그래밍에서도 다를 바 없다.'
- 환경이 Stream.iterate 거나 중간연산으로 limit를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.
- 대체로 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위 일때 병렬화의 효과가 가장 좋다.
    - 이 자료 구조들은 모두의 데이터를 우너하는 크기로 정확하고 손쉽게 나눌 수 있어서 일을 다수의 스레드에 분배하기에 좋다는 특징이 잇따.
    - 나누는 작업은 splititeraotr가 담당하며, Splititerator 객체는 Stream 이나 Iterable의 splititerator 메서드로 얻어올 수 있다.
    - 이 자료구조들의 또 다른 중요한 공통점은 원소들을 순차적으로 실행할 때 참조 지역성이 뛰어나다는 것이다.
    - 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있다느 ㄴ뜻이다.
- 참조 지역성이 가장 뛰어난 자료구조는 기본 타입의 배열이다.
- 기본 타입 배열에서는 (참조가 아닌) 데이터 자체가 메모리에 연속해서 저장되기 때문이다.
- 스트림 파이프라인의 종단 연산의 동작 방식 역시 병렬 수행 효율에 영향을 준다.
- 스트림을 잘못 병렬화하면 (응답 불가를 포함해) 성능이 나빠질 뿐만 아니라 결가ㅗ 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.
    - 결과가 잘못되거나 오동작하는 것은 안전 실패라고 한다.

> 스트림 병렬화는 오직 성능 최적화 수단임을 기억해야 한다.
> 
> 다른 최적화와 마찬가지로 변경 전후로 반드시 성능을 테스트하여 병렬화를 사용할 가치가 있는지 확인해야 한다.
> 
> 이상적으로는 운영시스템과 흡사한 환경에서 테스트 하는 것이 좋다.

### 핵심 정리

- 계산도 올바로 수행하고 성능도 빨라질 거라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말라.
- 스트림을 잘못 병렬화하면 프로그램을 오동작하게 하거나 성능을 급격히 떨어뜨린다.
- 병렬화하는 편이 낫다고 믿더라도, 수정 후의 코드가 여전히 정확한지 확인하고 운영환경과 유사한 조건에서 수행해보며 성능지표를 유심히 관찰하라.
- 그래서 계산도 정확하고 성능도 좋아졌음이 확실해졌을 때, 오직 그럴대만 병렬화 버전 코드를 운영 코드에 반영하라.

