# Day 14. 동시성 / Item 78~84


---
---


## Item 78. 공유 중인 가변 데이터는 동기화해 사용하라.

- synchronized 키워드는 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한다.
- 동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.
    - 이는 한 스레드가 만든 변화가 다른 스레드에게 언제 어떻게 보이는지를 규정한 자바의 메모리 모델 때문이다.
- volatile 한정자는 배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 읽게 됨을 보장한다.
- 가변 데이터는 단일 쓰레드에서만 쓰도록 하자.
    - 이 정채긍ㄹ 받아들였다면 그 사실을 문서에 남겨 유지보수 과정에서도 정책이 계속 지켜지도록 하는 게 중요하다.
- 한 스레드가 데이터를 다 수정한 후 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화 해도 된다. 그러면 그 객체를 다시 수정할 일이 생기기전 까지 다른 스레드들은 동기화 없이 자유롭게 값을 읽어갈 수 있다. 이런 객체를 사실상 불변이라하고 다른 스레드에 이런 객체를 건네는 행위를 안전 발행이라고 한다.
- 객체를 안전하게 발행하는 방법은 많다.
    - 클래스초기화 과자ㅓㅇ에서 객체를 정적필드, volatile 필드, final 필드, 혹은 보통의 락을 통해 접근하는 필드에 저장해도 된다. 그리고 동시성 컬렉션에 저장하는 방법도 있따.
     
### 핵심 정리
- 여러 스레드가 가변 데이터를 공유한다면 그데이터를 읽고 쓰는 동작은 반드시 동기화 해야 한다.
- 동기화하지 않으면 한 스레드가 수행한 변경을 다른 스레드가 보지 못할 수도 있다.
- 공유되는 가변 데이터를 동기화 하는 데 실패하면 응답 불가 상태에 빠지거나 안전 실패로 이어질 수 있다.
- 이는 디버깅 난이도가 가장 높은 문제에 속한다.
- 간헐적이거나 특정 타이밍에만 발생할 수 있고, VM 에 따라 현상이 달라지기도 한다.
- 배타적 실행은 필요 없고 스레드끼리의 통신만 필요하다면 volatile 한정자만으로 동기화할 수 있다. 다만 올바로 사용하기가 까다롭다.


-----


## Item 79 과도한 동기화는 피하라.
- 과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.
- 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 절대로 클라이언트에 양도하면 안된다.
    - 예를 들어 동기화된 영역 안에서는 재정의 할 수 잇는 메서드는 호출하면 안되며, 클라이언트가 넘겨준 함수 객체를 호출해서도 안된다.
- 기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다.
    - 락을얻고, 공유데이터를 검사하고, 필요하면 수정하고, 락을 놓는다. 오래걸리는 작업이라면 아이템 78의 지침을 어기지 않으면서 동기화 영역 바깥으로 옮기는 방법을 찾아보자.
- 멀티코어가 일반화된 오늘날, 과도한 동기화가 초래하는 진짜 비용은 락을 얻는데 드는 CPU시간이 아니다. 바로 경쟁하느라 낭비하는 시간, 즉 병렬로 실행할 기회를 잃고 모든 코어가 메모리를 일관되게 보기 위한 지연시간이 진짜 비용이다. 가상 머신의 코드 최적화를 제한한다는 점도 과도한 동기화의 또 다른 숨은 비용이다.
- 가변 클래스를 작성하려거든 다음 두 선택지 중 하나를 따르자.
    - 첫 번째 , 동기화를 전혀 하지말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화 하게 하자.
    - 두 번째, 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자 (아이템 82(
    - 단 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 두 번째 방법을 선택해야 한다.
- 여러 스레드가 호출할 가능성이 있는  메서드가 정적 필드를 수정한다면 그 필드를 사용하기 전에 반드시 동기해야 한다.
 
### 핵심 정리
- 교착 상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자.
- 일반화해 이야기하면, 동기화 영역 안에서의 작업은 최소한으로 줄이자.
- 가변 클래스를 설계 할 때는 스스로 동기화해야 할지 고민하자.
- 멀티코어 세상인 지금은 과도한 동기화를 피하는 게 과거 어느 때보다 중요하다 합당한 이유가 있을 때만 내부에서 동기화하고, 동기화했는지 여부를 문서에 명확히 밝히자.

-----
-----

## Item 80 스레드보다는 실행자, 태스크, 스트림을 애용하라.

java.util.concurrent 패키지 : 실행자 프레임워크라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.

```java
        ExecutorService exec = Executors.newSingleThreadExecutor();
        exec.execute(runnable); 
        exec.shutdown();
```

###실행자 서비스의 주요 기능들

- 특정 태스크가 완료되기를 기다린다. (코드79-2에서 본 get 메서드)
- 태스크 모음중 아무것 하나 (invokeANy 메서드) 혹은 모든 태스크 (invoke all 메서드) 가 완료되기를 기다린다.
- 실행자 서비스가 종료하기를 기다린다. (awaitTermination 메서드)
- 완료된 태스크들의 결과를 차례로 받는다(ExecutorCompletionService 이용)
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다. (ScheduledThreadPoolExecutor 이용)
- 큐를 둘 이상의 스레드가 처리하게 하고 싶다면 간단한 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스 (스레드 풀)를 생성하면 된다. 스레드 풀의 스레드 갯수는 고정할 수도 있고 필요에 따라 늘어나거나 줄어들게 설정할 수도 있다.
 
###  작업 단위를 나타내는 핵심 추상 개념이 태스크다.
- 태스크에는 두가지가 있는데 Runnable 과 Callable 이다.
- 그리고 태스크를 수행하는 일반적인 메커니즘이 바로 실행자 서비스다.


## Item 81 wait와 notify보다는 동시성 유틸리티를 애용하라.

- wait과 notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자.
- java.util.concurrent 의 고수준 유틸리티는 세 범주로 나눌 수 있다.
  - 바로 실행자 프레임워크, 동시성 컬렉션(concurrent collection), 동기화 장치 (synchronizer)다.
- 동시성 컬렉션은 List, Queue, Map 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션이다.
    - 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며, 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다.
- Collections.synchronizedMap 보다는 ConcurrentHashMap을 사용하는게 훨씬 좋다.
- 시간 간격을 잴 때는 항상 SYstem.currentTimeMillies 가 아닌 System.nanoTime을 사용하자.
- 레거시 코드인 wait 메서드를 사용할 때는 반드시 대기 반복문 관용구를 사용하라. 반복문 밖에서는 절대로 호출하지 말자.
 
### 핵심 정리
- wait와 notify를 직접 사용하는 것을 동시성 '어셈블리 언어'로 프로그래밍하는 것에 비유할 수 있다.
- 반면 java.util.concurrent는 고수준 언어에 비유할 수 잇다.
- 코드를 새로 작성한다면 wait와 notify를 쓸 이유가 거의(어쩌면 전혀) 없다.
- 이들을 사용하는 레거시 코드를 유지보스해야 한다면 wait는 항상 표준 관용구에 따라 while 문 앞에서 호출하도록 하자.
- 일반적으로 notify 보다는 notifyAll을 사용해야 한다. 혹시라도 notify 를 사용한다면 응답 불가 상태에 빠지지 않도록 각별히 주의하자.

-----
-----

## Item 82스레드 안전성 수준을 문서화하라.

- 메서드 선언에 syncrhonized 한정자를 선언할지는 구현 이슈일 뿐 API 에 속하지 않는다.
- 멀티스레드 환경에서도 API 를 안전하게 사용하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야 한다.
 
### 스레드 안정성이 높은 수준으로 나열
    - 불변
    - 무조건적 스레드 안전
    - 조건부 스레드 안전
    - 스레드 안전하지 않음
    - 스레드 적대적

### 락 필드는 항상 final 로 선언하라.
- 비공개 락 객체 관용구는 무조건 스레드 안전 클래스에서만 사용할 수 있다.
- 조건부 스레드 안전 클래스에서는 특정 호출 순서에 필요한 락이 무엇인지를 클라이언트에게 알려줘야 하므로 이 관용구를 사용할 수 없다.
 
### 핵심 정리
- 모든 클래스가 자신의 스레드 안정성 정보를 명확히 문서화해야 한다.
- 정확한 언어로 명확히 설명하거나 스레드 안정성 애너테이션을 사용할 수 있다.
- syncrhonized 한정자는 문서화와 관련이 없다.
- 조건부 스레드 안전 클래스는 메서드를 어떤 순서로 호출할 대 외부 동기화가 요구되고, 그때 어떤 락을 얻어야 하는지 알려줘야 한다.
- 무조건적 스레드 안전 클래스를 작성할 대는 synchronized 메서드가 아닌 비공개 락 객체를 사용하자.
- 이렇게 해야 클라이언트나 하위 클래스에서 동기화 메커니즘을 깨뜨리는 걸 예방할 수 있고, 필요하다면 다음에 더 정교한 동시성을 제어 메커니즘으로 재구현할 여지가 생긴다.

-----
-----


## Item 83 지연 초기화는 신중히 사용하라.

- 지연 초기화는 필드으 ㅣ초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법이다.
- 지연 초기화는 양날의 검이기 때문에 필요할 때까지는 지연 초기화를 하지말라.
- 대부분의 상황에서 일반적인 초기화가 지연 초기화보다 낫다.
- 지연 초기화가 초기화 순환성(initilalizaition circulairty)을 깨뜨릴 것 같으면 syncrhonized를 단 접근자를 사용하자.
- 성능 때문에 정적 필드를 지연 초기화해야 한다면 지연 초기화 홀더 클래스 관용구를 사용하자.
- 성능 때문에 인스턴스 필드 지연 초기화해야 한다면 이중검사 관용구를 사용하라.
 

### 핵심 정리
- 대부분의 필드는 지연시키지 말고 곧바로 초기화해야 한다.
- 성능 때문에 혹은 위험한 초기화 순환을 막기 위해 꼭 지연 초기화를 써야 한다면 올바른 지연 초기화 기법을 사용하자.
- 인스턴스 필드에는 이중검사 관용구를, 정적 필드에는 지연 초기화 홀더 클래스 관용구를 사용하자.
- 반복해 초기화해도 괜찮은 인스턴스 필드에는 단일검사 관용구도 고려 대상이다.


-----
-----


## Item 84 프로그램의 동작을 스레드 스케줄러에 기대지 말라.

- 여러 스레드가 실행중이면 운영체제의 스레드 스케줄러가 어떤 스레드를 얼마나 오래 실행할지 정한다. 정상적인 운영체제라면 이 작업을 공정하게 수행하지만 구체적인 스케줄링 정책은 운영체제마다 다를 수 있다. 따라서 잘 작성된 프로그램이라면 이 정책에 좌지우지돼서는 안된다.
- 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.
- 견고하고 빠릿하고 이식성 좋으 ㄴ프로그램을 작성하는 가장 좋은 방법은 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것이다. 그래야 스레드 스케줄러가 고민할 거리가 줄어든다.
- 스레드는 당장 처리해야 할 작업이 없다면 실행돼서는 안된다.
    - 실행자 프레임워크를 예로 들면, 스레드 풀 크기를 적절히 설정하고 작업은 짧게 유지하면 된다.
    - 단, 너무 짧으면 작업을 분배하는 부담이 오히려 성능을 떨어뜨릴 수도 있다.
- 스레드는 절대 바쁜 대기 상태가 되면 안된다.
    - 공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사해서는 안된다는 뜻이다.
    - 바쁜 대기는 스레드 스케줄러의 변덕에 취약할 뿐 아니라, 프로세서에 큰 부담을 주어 다른 유용한 작업이 실행될 기회를 박탈한다.
- 스레드 우선순위는 자바에서 이식성이 가장 나쁜 특성에 속하낟.
 
### 핵심 정리
- 프로그램의 동작을 스레드 스케줄러에 기대지 말자.
- 견고성과 이식성으 ㄹ모두 해치는 행위다.
- 같은 이유로, Thread.yield와 스레드 우선순위에 의존해서도 안 된다.
- 이 기능들은 스레드 스케줄러에 제공하는 힌트이 ㄹ뿐이다.
- 스레드 우선순위는 이미 잘 동작하는 프로그램의 서비스 품질을 높이기 위해 드물게 스일 수는 잇지만, 간신히 동작하는 프로그램을 '고치는 용도'로 사용해서는 절대 안 된다.

---

