# Day 1. 객체의 생성 / Item 1~5

## Item 1. 생성자 대신 정적 팩토리 메서드를 고려하라.

> 클래스의 인스턴스를 얻기위한 일반적인 생성자 방법 대신 인스턴스를 반환하는 정적 팩터리 메서드 기법을 고려해 볼수 있다.

```java
public static Boolean valueOf(boolean b){
        return b?Boolean.TRUE:Boolean.FALSE;
        }
```

## 장점

1. 특성의 묘사를 잘 할 수 있는 이름을 가질 수 있다.

- 하나의 클래스에 생성자가 여러개 필요할 것 같으면 생성자를 정적 팩터리 메서드로 바꾸자.
- 빌더도 하나의 방법이라고 볼수 있다.

2. 호출 할때 마다 인스턴스를 새로 생성하지는 않아도 된다.

- 불변 클래스는 미리 만들어 놓고. 캐싱/재활용하는 식. ex) boollean value of.

3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

4. 입력 매개 변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

- 예를들어 리턴 타입이 Enum 이면 Enum 구현 또는 상속한 하위클래스를 반환해도 된다.

5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

단점 1 상속을 하려면 public 이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다. 2 정적 팩터리 메서드는 프로그래머가 찾기 어렵다. 보통 팩터리 메서드는
생성자와 달리 API 에 명확히 들어나지 않는다. 흔히 사용하는 정적 팩터리 메서드에 흔히 사용하는 명명 방식들

```
// from
Date d = Date.from(param);
// of
Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
// valueOf
BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE)
```

---

## Item 2 생성자에 매개변수가 많다면 빌더를 고려하라.

---

## Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라.

- 싱글턴이란 인스턴스르 오직 하나만 생성 할 수 있는 클래스를 말한다. 싱글턴의 예는 함수와 같은 무상태 객체나 유일해야하는 시스템 컴포넌트를 들 수 있다.
- 그런데 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워 질 수 있다.
- 타입을 인터페이스로 정의한다음 그 인터페이스를 구현해서 만든 싱글턴이 아니라면 싱글턴 인스턴스를 가짜 구현으로 대체 할 수 없기 때문이다.

### 싱글턴을 만드는 방식 두방식 모두 생성자는 private 으로 감춰두는 것이다.

#### 방법1 : 유일한 인스턴스에 접근할 수 잇는 수단으로 public static 멤버를 하나 만들어둔다.

- private 생성자는 public static final 필드인 Elvis.INSTANCE를 초기화할 때 딱 한번만 호출된다.
- ***예외로는 리플렉션 API 아이템 65인 AccessibleObject.setAccesible을 사용해 private 생성자를 호출할 수 있다.
- 이러한 공격을 방어하려면 생성자를 수정하여 두번째 객체를 생성하려 할때 예외처리를 해주어야한다.

```
public class Evlis{
    public static final Elivs INSTANCE = new Elvis();
    private ELvis() { .... }

    public void leaveTheBuilding() { .... }
}

```

#### 방법2 : 정적 팩터리 메서드 private static final Clazz INSTANCE = new Clazz(); private 생성자 public static Elivs getINstanc(){};

### 각 방법의 장점

- 방법 1
    - 싱글턴임이 API 에 명백히 드러남.
    - 간결함
- 방법 2
    - API 를 바꾸지 않고도 싱글턴이 아니게 변경하기 쉽다. 팩터리 메서드가 유일한 인스턴스 아닌 스레드 별로 다른 인스턴스를 넘겨주게 할수있따.
    - 원하면 정적팩터리를 제네릭 싱글턴 팩터리로 만들수 있다. (item 30)
    - 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있음. Elivs::getInstance를 Supplier<Elivs>로 사용하는 방식이다.
    - 이러한 장점들이 굳이 필요하지 않다면 public 필드 방식이 좋다.

> 둘 중 하나의 방식으로 만든 싱글턴 클래스를 직렬화하려면(12장) 단순히 serializable을 구현한다고 선언하는 것만으로는 부족하다.
>
> 모든 인스턴스 필드를 일시적(transient)이라 선언하고 readResolve 메서드를 제공해야한다 (item89)
>
> 이렇게 하지 않으면 직렬화된 인스턴스를 역직렬화할 때 마다 새로운 인스턴스가 만들어진다.
>
> 싱글턴임을 보장해주는 readResolve()메서드

### 방법 3: 원소가 하나인 열거 타입을 선언하는것.

```java
public enum Elvis {INSTANCE;}
```

- 퍼블릭 필드방식과 비슷하지만 더 간결하고 추가의 노력없이 직렬화할 수 있다.
- 복잡한 직렬화 상황이나 리플렉션 공격에서도 제2의 인스턴스가 생기는 일을 완벽히 막아준다.
- 조금 부자연스러워 보일 수는 있으나 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.
- 단 Enum 다른 클래스를 상속할 수 없고 다른 인터페이스를 구현하도록 선언할 수는 있다.

---

## item 4 / 인스턴스화를 막으려거든 private 생성자를 사용하라

### 정적 메서드와 필드만을 담은 클래스들이 분명히 필요할 때가 있다.

1. java.utl.Arrays.처럼 기본 타입 값이나 배열 관련 메서드들을 모아 놓을수 있다.
2. java.util.Collections 처럼 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드를 모아놓을 수도 있다.
3. 마지막으로 final 클래스와 관련한 메소드들을 모아놓을 때도 사용한다.

- 정적메소드만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰라려고 설계한게 아니다.
- 하지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본생성자를 만들어준다.
- 의도치 않게 인스턴스화 할수 있게 된 클래스가 종종 목격되곤 한다.
- 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.
- 하위 클래스를 만들어 인스턴스화하면 그만이다.
- 이를 본 사용자는 상속해서 쓰라는 뜻으로 오해할 수 있으니 더 큰 문제다 (아이템19)
- 다행히도 인스턴스화를 막는 방법은 간단하다.
    - 컴파일러가 기본생성자를 생성하는건 명시된 생성자가 없을때니 private 생성자를 추가하면 된다.
    - 실수로라도 생성자를 생성하지 않도록 prviate 생성자 내부에 AssertionError를 던져준다.
    - 그런데 직관적이지 않을 수 있느니 앞의 코드 처럼 적절한 주석을 달아주도록하자. 
- 이방식은 상속을 불가능하게 하는 효과도 있다.
    - 모든 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출하게 되는데,
    - 이를 private으로 선언했으니 하위클래스가 상위 클래스의 생성자에 접근할 일이 없다.



---

## item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

> 많은 클래스가 하나 이상의 자원에 의존한다.

- 클래스의 자원들을 static final로 구현한 모습을 드물지 않게 볼수 있다.
- 하지만 우리는 하나의 자원만을 사용한다고 한정지으면 안된다.
- 사용자의 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
- 여러 자원을 지원할 수 있도록 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식을 택해야한다.
- 이를 의존 객체 주입 패턴이라고 하는데 아주 단순하여 이름이 있다는 사실도 모르고 사용하고는 한다.
- 방법은 private static final 로 한정짓는것이아닌 생성자로 주입하여 Objects.requireNonNull 로 null 객체 주입 방지를 막아주는 것이다.

> 이 패턴의 쓸만한 변형으로 생성자에 자원 팩터리를 넘겨주는 방식이 있다. 팩터리 메서드 패턴이다.

- ```Supplier<T>``` 인터페이스가 팩터리를 표현한 완벽한 예다.
- 의존 객체 주입이 유연성과 테스트용이성을 개선해 주긴 하지만, 의존성이 수천개나 되는 큰 프로젝트에서는 코드를 어지럽게 만들기도한다.
- 의존 객체 주입 프레임워크를 사용하면 이런 어질러짐을 해소할 수 있다. 
- 프레임워크 활용법은 이 책에서 다룰 주제는 아니지만 이들 프레임워크는 의존 객체를 직접 주입하도록 설계된 API 를 알맞게 응용해 사용하고 있음을 언급해둔다. 
